# 원시 값과 객체

## 비교

원시: 변경 불가능한 값 vs 객체: 변경 가능한 값 -> 여기서 변경 불가능/가능은 변수가 아니라 값에 대한 진술임.
원시: 값을 변수에 할당하면 메모리에는 실제 값이 저장 vs 객체: 참조 값이 저장

## 변수와 상수

변수의 상대 개념인 상수는 재할당이 금지된 `변수`를 말함. 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고 할 수 있지만 `변수는 언제든지 재할당을 통해 값을 변경할 수 있지만` 상수는 단 한 번만 할당이 허용되므로 변수의 `값을 변경할 수 없다.` 따라서 상수와 변경 불가능한 값을 동일시하는 것은 곤란하다. 상수는 재할당이 금지된 변수일 뿐.

## 유사배열객체 String

문자열은 유사배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있으나 문자열은 원시값이므로 변경할 수는 없다.

```js
var str = "string";

str[0] = "S";

console.log(str); // string
```

# 함수

- 표현식이 아닌 문인 함수 선언문은 그룹 연산자의 피연산자로 사용할 수 없다.
- 이름이 있는 기명 함수 리터럴은 코드의 문맥에 따라 함수 선언문 또는 함수 리터럴 표현식으로 해석된다. 함수 선언문과 함수 리터럴 표현식은 함수 객체를 생성한다는 점에서 동일하지만 호출에 차이가 있다.
  - 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.(호이스팅 된다.)
  - 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.(호이스팅 되지 않는다.)
  - 이러한 차이는 두 방식간의 생성 시점이 다르기 때문에 발생한다.
  - 여기서 함수 선언문으로 호이스팅 된 함수와 var 변수가 호이스팅된 경우는 차이가 있다. 변수는 `undefined`로 초기화되는 반면 함수 선언문은 `함수 객체`로 초기화된다.
- 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.
- JS의 함수는 값처럼 변수에 할당할 수도 있고 프로퍼티 값이 될 수도 있으며 배열의 요소가 될 수도 있다. 이처럼 값의 성질을 갖는 객체를 `일급 객체`라고 한다.

## 함수의 호이스팅

- 함수 표현식은 변수 선언문과 변수 할당문을 한 번에 기술한 축약 표현과 동일하게 동작한다.
- 함수 표현식의 함수 리터럴은 변수의 경우와 동일하게 할당문이 실행되는 시점에 평가되어 함수 객체가 된다. 즉, 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.
- 따라서 함수 호이스팅의 위험이 없는 함수 표현식이 더 권장되는 방식이다.

## NaN에 대한 재정리

- `Not a Number`의 약자
- 수치 연산이나 숫자 변환이 실패했을 때 반환되는 특별한 값
- 수학적으로 유효한 숫자가 아님에도 불구하고 타입은 실제로 `Number`로 취급됨
- 자기 자신과도 같지 않음 -> 반사성 부재, 일반적인 비교 연산자로 NaN을 판별할 수 없음 -> Number.isNaN() 메서드를 통해 판별

## 함수에서 기본 매개변수의 처리

- 매개변수의 기본값은 호출 시 인수를 전달하지 않은 경우와 undefined를 전달한 경우에만 유효
- 기본값을 활용하면 간단하게 예외상황을 의도를 담아 처리할 수 있다.

## 콜백함수와 고차함수

- 함수의 매개변수를 통해 다른 함수의 내부로 `전달되는 함수를 콜백 함수`라고 하고 매개변수를 통해 함수의 외부에서 콜백 함수를 `전달받은 함수를 고차 함수`라고 함.
- 중첩 함수는 고정되어 있어서 교체하기 곤란하지만 콜백 함수는 함수 외부에서 고차 함수 내부로 주입되기 때문에 자유롭게 교체할 수 있다는 장점이 있다. 즉, 고차 함수는 콜백 함수를 자신의 일부로 합성한다.

## 순수함수

- 부수 효과가 없는 함수
- 순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.
- 어떤 외부 상태에도 의존하지 않으며 외부 상태를 변경하지도 않는 함수.
- 함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임이다.

# 스코프

- 모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프라고 한다.
- 지역 스코프는 함수에 의해서만 생성된다.

## 렉시컬 스코프(정적 스코프)

- JS에서는 함수를 어디서 호출했는지가 아니라 함수를 `어디서 정의했는지`에 따라 상위 스코프를 결정한다. 함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다. 즉, 함수의 상위 스코프는 자신이 정의된 스코프다.

# 전역 변수와 지역 변수, 그리고 스코프

- 전역 변수의 무분별한 사용은 위험하다. 뚜렷한 이유가 없다면 지역 변수를 사용해야 한다.
- 전역 변수는 애플리케이션의 생명주기를 같이하기 때문. -> var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다. 이는 전역 변수의 생명 주기가 전역 객체의 생명 주기와 일치한다는 것을 의미한다.
  - 전역 객체: 코드가 실행되기 이전 단계에 JS 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체.
- 지역 변수는 함수의 생명주기를 같이한다.

## 지역 변수와 호이스팅

- 호이스팅은 스코프 단위로 동작한다.

```js
var x = "global";

function foo() {
  console.log(x); // local -> 지역 변수는 호출과 동시에 선언되고 undefined를 할당받는다.
  var x = "local";
}
foo();
console.log(x);
```

# let 선언 키워드

- var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정하는 함수 레벨 스코프를 따르지만 let 키워드로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.
- let 키워드로 선언한 변수는 `선언 단계`와 `초기화 단계`가 분리되어 진행된다. 즉, 런타임 이전에 JS 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달했을 때 실행된다.
- 하지만 let 키워드로 선언한 변수가 호이스팅이 발생하지 않는 것은 아님. 아래 코드에서 만약 호이스팅이 발생하지 않는다면 1을 출력해야 하지만 참조 에러가 발생하는 것으로 호이스팅이 발생함을 알 수 있다. 다만 호이스팅이 발생하지 않는 것 처럼 동작할 뿐.

```js
let foo = 1; // 전역 변수

{
  console.log(foo); // 참조 에러 발생
  let foo = 2; // 지역 변수
}
```

# const 선언 키워드

- const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.
- var, let 키워드와 달리 재할당이 금지된다.
- const 키워드로 선언된 변수에 원시 값을 할당한 경우 원시 값은 변경할 수 없는 값이고 const 키워드에 의해 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없다.

# this

- this는 객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수다. this가 가리키는 값, 즉 this 바인딩은 `함수 호출 방식`에 따라 동적으로 결정된다.
  - 일반 함수로서 호출: 전역 객체
  - 메서드로서 호출: 메서드를 호출한 객체
  - 생성자 함수로서 호출: 생성자 함수가 (미래에)생성할 인스턴스
