# 객체지향 프로그래밍
- 객체의 `상태`를 나타내는 데이터와 상태 데이터를 조작할 수 있는 `동작`을 하나의 논리적인 단위로 묶어 생각한다. 

## 프로토타입 객체
- 생성자 함수를 통해 많은 인스턴스 생성에 대응할 수 있지만 동일한 동작을 하는 메서드를 인스턴스 생성시 마다 생성할 필요는 없다. 이를 위해 JS는 프로토타입 객체를 통해 메서드 상속을 구현한다. 물론 프로퍼티도 상속받을 수 있다. 
```js
function Circle(radius) {
  this.radius = radius;
  Circle.prototype.getArea = function () {
    return Math.PI * this.radius **2;
  };
}
// 아래 두 인스턴스는 동일한 메서드 getArea를 공유한다. 
const circle1 = Circle(2)
const circle2 = Circle(5)
```
- 프로토타입은 어떤 객체의 상위(부모)객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티(메서드 포함)를 제공한다. 
- 모든 객체는 하나의 프로토타입을 갖는다. 그리고 모든 프로토타입은 생성자 함수와 연결되어 있다. 

## 왜 생성자 함수와 객체 사이에 프로토타입 객체가 존재해야 하는 것일까?
- 반드시 존재해야 하는 것은 아님. 실제로 ES5부터 프로토타입 객체 없이 객체를 생성할수도 있다. 하지만 이 경우 속성과 메서드를 상속받지 못하므로 재사용의 관점에 적절하지는 않다. 
- 아! 프로토타입은 상속과 프로퍼티 검색을 위한 메커니즘임. 또한 프로토타입은 기나긴 상속 체인을 가질 수 있음. 따라서 고유한 생성자 함수와 별개로 상속만을 위한 프로토타입 객체를 두어 기나긴 체인을 구현할 수 있게됨. 

## 프로토타입 체인과 객체의 생성 과정
1. 객체 생성 시 빈 객체가 만들어지고 그 내부의 `__proto__` 참조가 생성자 함수의 프로토타입 객체로 설정됨
2. 이후 객체의 속성 접근 시, 해당 객체에 직접 정의되지 않은 속성이나 메소드는 이 프로토타입 객체를 통해 검색되어 상속

- 이렇게 프로토타입 객체에 메소드나 공통 데이터를 정의하면, 모든 생성된 객체가 이를 공유하게 되어 각 객체에 동일한 메소드를 반복해서 갖는 것을 방지.

## 프로토타입 체인
- 프로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다. 순환 참조하는 프로토타입 체인이 만들어지면 프로토타입 체인 종점이 존재하지 않기 때문에 프로토타입에서 프로퍼티를 검색할 때 무한 루프에 빠진다. 

## __proto__ 접근자 대신 사용 권장되는 메서드
- Object.getPrototypeOf(obj): 객체의 프로토타입을 취득
- Object.setPrototypeOf(obj): 객체의 프로토타입을 교체 

## 생성자 함수와 프로토타입 그리고 객체의 연결성
생성자 함수와 프로토타입은 프로토타입의 `constructor`프로퍼티로 연결된다.
객체와 프로토타입은 객체의 `__proto__`프로퍼티로 연결된다. 객체는 프로토타입의 `constructor`프로퍼티를 상속받기 때문에 이를 활용해 생성자 함수와 연결될 수 있다. 

## 사용자 정의 생성자 함수와 프로토타입 그리고 프로토타입의 프로토타입
- 사용자 정의 생성자 함수는 자신이 평가되어 함수 객체로 생성되는 시점에 프로토타입도 더불어 생성되며, 생성된 프로토타입의 프로토타입은 언제나 `Object.prototype`이다.

## 하위 객체를 통해 프로토타입의 프로퍼티를 변경 및 삭제하는 것은 불가능하다. 


# 원시값과 래퍼 객체
- 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체라 한다. 
- 원시값을 객체처럼 사용하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하여 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌린다. 
- 그런데 왜 원시값을 임시 객체로 변환했다가 연산 후 되돌리는 번거로운 작업을 하는 것일까?? 이는 원시값의 데이터 불변성을 유지하기 위해서다. 알다시피 객체는 mutable하고 원시값은 immutable하다. 또한 메모리 효율성 면에서 임시 래퍼를 통해 동작하는 편이 더 효율적인 동작을 보장한다. 

# this 
- 생성자 함수에 의한 객체 생성 방식은 먼저 생성자 함수를 정의한 이후 new 연산자와 함께 생성자 함수를 호출하는 단계가 추가로 필요하다. 다시 말해, 생성자 함수로 인스턴스를 생성하려면 먼저 생성자 함수가 존재해야 한다. 
- 따라서 자신이 생성할 인스턴스를 가리키는 특수한 식별자가 필요 -> `this`
- 일반 함수로 호출된 모든 함수(중첩 함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다. 따라서 아래의 . `that`코드로 중첩 함수의 경우 this 자기 참조 변수를 활용할 수 있다.
```js
var value = 1;

const obj = {
  value = 100,
  foo() {
    const that = this;

    setTimeout(function () {
      console.log(that.value);
    }, 100);
  }
};
```
- 또는 `bind`를 통해서도 this 바인딩을 진행할 수 있다.
```js
var value = 1;

const obj = {
  value = 100,
  foo() {

    setTimeout(function () {
      console.log(this.value);
    }.bind(this), 100);
  }
};
```
- 화살표 함수의 this의 경우 상위 스코프의 this를 가리킨다. 